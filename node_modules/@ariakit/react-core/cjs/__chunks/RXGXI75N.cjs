"use strict";Object.defineProperty(exports, "__esModule", {value: true});"use client";


var _QKKT6RXXcjs = require('./QKKT6RXX.cjs');


var _SMKW5GKScjs = require('./SMKW5GKS.cjs');




var _VKYTJKYNcjs = require('./VKYTJKYN.cjs');


var _WLJVTO7Acjs = require('./WLJVTO7A.cjs');





var _JTVNRMACcjs = require('./JTVNRMAC.cjs');




var _WYXAWBLEcjs = require('./WYXAWBLE.cjs');

// src/disclosure/disclosure-content.tsx
var _react = require('react');
var _misc = require('@ariakit/core/utils/misc');
var _jsxruntime = require('react/jsx-runtime');
function afterTimeout(timeoutMs, cb) {
  const timeoutId = setTimeout(cb, timeoutMs);
  return () => clearTimeout(timeoutId);
}
function afterPaint(cb) {
  let raf = requestAnimationFrame(() => {
    raf = requestAnimationFrame(cb);
  });
  return () => cancelAnimationFrame(raf);
}
function parseCSSTime(...times) {
  return times.join(", ").split(", ").reduce((longestTime, currentTimeString) => {
    const currentTime = parseFloat(currentTimeString || "0s") * 1e3;
    if (currentTime > longestTime)
      return currentTime;
    return longestTime;
  }, 0);
}
function isHidden(mounted, hidden, alwaysVisible) {
  return !alwaysVisible && hidden !== false && (!mounted || !!hidden);
}
var useDisclosureContent = _VKYTJKYNcjs.createHook.call(void 0, 
  (_a) => {
    var _b = _a, { store, alwaysVisible } = _b, props = _WYXAWBLEcjs.__objRest.call(void 0, _b, ["store", "alwaysVisible"]);
    const context = _SMKW5GKScjs.useDisclosureProviderContext.call(void 0, );
    store = store || context;
    _misc.invariant.call(void 0, 
      store,
      process.env.NODE_ENV !== "production" && "DisclosureContent must receive a `store` prop or be wrapped in a DisclosureProvider component."
    );
    const id = _JTVNRMACcjs.useId.call(void 0, props.id);
    const [transition, setTransition] = _react.useState.call(void 0, null);
    const open = store.useState("open");
    const mounted = store.useState("mounted");
    const animated = store.useState("animated");
    const contentElement = store.useState("contentElement");
    _JTVNRMACcjs.useSafeLayoutEffect.call(void 0, () => {
      if (!animated)
        return;
      if (!(contentElement == null ? void 0 : contentElement.isConnected)) {
        setTransition(null);
        return;
      }
      return afterPaint(() => {
        setTransition(open ? "enter" : "leave");
      });
    }, [animated, contentElement, open]);
    _JTVNRMACcjs.useSafeLayoutEffect.call(void 0, () => {
      if (!store)
        return;
      if (!animated)
        return;
      if (!contentElement)
        return;
      if (!transition)
        return;
      if (transition === "enter" && !open)
        return;
      if (transition === "leave" && open)
        return;
      if (typeof animated === "number") {
        const timeoutMs2 = animated;
        return afterTimeout(timeoutMs2, store.stopAnimation);
      }
      const {
        transitionDuration,
        animationDuration,
        transitionDelay,
        animationDelay
      } = getComputedStyle(contentElement);
      const delay = parseCSSTime(transitionDelay, animationDelay);
      const duration = parseCSSTime(transitionDuration, animationDuration);
      const timeoutMs = delay + duration;
      if (!timeoutMs)
        return;
      return afterTimeout(timeoutMs, store.stopAnimation);
    }, [store, animated, contentElement, open, transition]);
    props = _JTVNRMACcjs.useWrapElement.call(void 0, 
      props,
      (element) => /* @__PURE__ */ _jsxruntime.jsx.call(void 0, _QKKT6RXXcjs.DialogScopedContextProvider, { value: store, children: element }),
      [store]
    );
    const hidden = isHidden(mounted, props.hidden, alwaysVisible);
    const style = hidden ? _WYXAWBLEcjs.__spreadProps.call(void 0, _WYXAWBLEcjs.__spreadValues.call(void 0, {}, props.style), { display: "none" }) : props.style;
    props = _WYXAWBLEcjs.__spreadProps.call(void 0, _WYXAWBLEcjs.__spreadValues.call(void 0, {
      id,
      "data-enter": transition === "enter" ? "" : void 0,
      "data-leave": transition === "leave" ? "" : void 0,
      hidden
    }, props), {
      ref: _JTVNRMACcjs.useMergeRefs.call(void 0, id ? store.setContentElement : null, props.ref),
      style
    });
    return props;
  }
);
var DisclosureContentImpl = _VKYTJKYNcjs.createComponent.call(void 0, 
  (props) => {
    const htmlProps = useDisclosureContent(props);
    return _VKYTJKYNcjs.createElement.call(void 0, "div", htmlProps);
  }
);
var DisclosureContent = _VKYTJKYNcjs.createComponent.call(void 0, 
  (_a) => {
    var _b = _a, { unmountOnHide } = _b, props = _WYXAWBLEcjs.__objRest.call(void 0, _b, ["unmountOnHide"]);
    const context = _SMKW5GKScjs.useDisclosureProviderContext.call(void 0, );
    const store = props.store || context;
    const mounted = _WLJVTO7Acjs.useStoreState.call(void 0, 
      store,
      (state) => !unmountOnHide || (state == null ? void 0 : state.mounted)
    );
    if (mounted === false)
      return null;
    return /* @__PURE__ */ _jsxruntime.jsx.call(void 0, DisclosureContentImpl, _WYXAWBLEcjs.__spreadValues.call(void 0, {}, props));
  }
);
if (process.env.NODE_ENV !== "production") {
  DisclosureContent.displayName = "DisclosureContent";
}





exports.isHidden = isHidden; exports.useDisclosureContent = useDisclosureContent; exports.DisclosureContent = DisclosureContent;
