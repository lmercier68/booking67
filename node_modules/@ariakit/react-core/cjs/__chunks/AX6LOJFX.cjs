"use strict";Object.defineProperty(exports, "__esModule", {value: true});"use client";


var _ORT5QOHHcjs = require('./ORT5QOHH.cjs');


var _7ARL6QHNcjs = require('./7ARL6QHN.cjs');




var _VKYTJKYNcjs = require('./VKYTJKYN.cjs');





var _JTVNRMACcjs = require('./JTVNRMAC.cjs');




var _WYXAWBLEcjs = require('./WYXAWBLE.cjs');

// src/hovercard/hovercard-anchor.ts
var _react = require('react');
var _events = require('@ariakit/core/utils/events');
var _misc = require('@ariakit/core/utils/misc');
var useHovercardAnchor = _VKYTJKYNcjs.createHook.call(void 0, 
  (_a) => {
    var _b = _a, { store, showOnHover = true } = _b, props = _WYXAWBLEcjs.__objRest.call(void 0, _b, ["store", "showOnHover"]);
    const context = _ORT5QOHHcjs.useHovercardProviderContext.call(void 0, );
    store = store || context;
    _misc.invariant.call(void 0, 
      store,
      process.env.NODE_ENV !== "production" && "HovercardAnchor must receive a `store` prop or be wrapped in a HovercardProvider component."
    );
    const mounted = store.useState("mounted");
    const disabled = _misc.disabledFromProps.call(void 0, props);
    const showTimeoutRef = _react.useRef.call(void 0, 0);
    _react.useEffect.call(void 0, () => () => window.clearTimeout(showTimeoutRef.current), []);
    _react.useEffect.call(void 0, () => {
      const onMouseLeave = (event) => {
        if (!store)
          return;
        const { anchorElement } = store.getState();
        if (!anchorElement)
          return;
        if (event.target !== anchorElement)
          return;
        window.clearTimeout(showTimeoutRef.current);
        showTimeoutRef.current = 0;
      };
      return _events.addGlobalEventListener.call(void 0, "mouseleave", onMouseLeave, true);
    }, [store]);
    const onMouseMoveProp = props.onMouseMove;
    const showOnHoverProp = _JTVNRMACcjs.useBooleanEvent.call(void 0, showOnHover);
    const isMouseMoving = _JTVNRMACcjs.useIsMouseMoving.call(void 0, );
    const onMouseMove = _JTVNRMACcjs.useEvent.call(void 0, 
      (event) => {
        store == null ? void 0 : store.setAnchorElement(event.currentTarget);
        onMouseMoveProp == null ? void 0 : onMouseMoveProp(event);
        if (disabled)
          return;
        if (event.defaultPrevented)
          return;
        if (showTimeoutRef.current)
          return;
        if (!isMouseMoving())
          return;
        if (!store)
          return;
        if (!showOnHoverProp(event))
          return;
        const { showTimeout, timeout } = store.getState();
        showTimeoutRef.current = window.setTimeout(() => {
          showTimeoutRef.current = 0;
          if (!isMouseMoving())
            return;
          store == null ? void 0 : store.show();
        }, showTimeout != null ? showTimeout : timeout);
      }
    );
    props = _WYXAWBLEcjs.__spreadProps.call(void 0, _WYXAWBLEcjs.__spreadValues.call(void 0, {}, props), {
      ref: _JTVNRMACcjs.useMergeRefs.call(void 0, 
        store.setAnchorElement,
        // We need to set the anchor element as the hovercard disclosure
        // disclosure element only when the hovercard is shown so it doesn't get
        // assigned an arbitrary element by the dialog component.
        mounted ? store.setDisclosureElement : void 0,
        props.ref
      ),
      onMouseMove
    });
    props = _7ARL6QHNcjs.useFocusable.call(void 0, props);
    return props;
  }
);
var HovercardAnchor = _VKYTJKYNcjs.createComponent.call(void 0, 
  (props) => {
    const htmlProps = useHovercardAnchor(props);
    return _VKYTJKYNcjs.createElement.call(void 0, "a", htmlProps);
  }
);
if (process.env.NODE_ENV !== "production") {
  HovercardAnchor.displayName = "HovercardAnchor";
}




exports.useHovercardAnchor = useHovercardAnchor; exports.HovercardAnchor = HovercardAnchor;
