"use strict";Object.defineProperty(exports, "__esModule", {value: true});"use client";


var _VZINRVVHcjs = require('./VZINRVVH.cjs');


var _KVNENCXTcjs = require('./KVNENCXT.cjs');


var _A5IFXY4Jcjs = require('./A5IFXY4J.cjs');


var _FU2U6RZLcjs = require('./FU2U6RZL.cjs');


var _NIEATM7Rcjs = require('./NIEATM7R.cjs');


var _ZMMVJ3OTcjs = require('./ZMMVJ3OT.cjs');


var _OVN5OYWKcjs = require('./OVN5OYWK.cjs');

// src/press.ts
var _dom = require('@ariakit/core/utils/dom');




var _focus = require('@ariakit/core/utils/focus');
var clickableInputTypes = [
  "button",
  "color",
  "file",
  "image",
  "reset",
  "submit"
];
async function submitFormByPressingEnterOn(element, options) {
  const { form } = element;
  if (!form)
    return;
  const elements = Array.from(form.elements);
  const validInputs = elements.filter(
    (el) => el instanceof HTMLInputElement && _dom.isTextField.call(void 0, el)
  );
  const submitButton = elements.find(
    (el) => (el instanceof HTMLInputElement || el instanceof HTMLButtonElement) && el.type === "submit"
  );
  if (validInputs.length === 1 || submitButton) {
    await _FU2U6RZLcjs.dispatch.submit(form, options);
  }
}
function isNumberInput(element) {
  return element instanceof HTMLInputElement && element.type === "number";
}
async function incrementNumberInput(element, by = 1) {
  const value = +element.value + by;
  const max = element.max ? +element.max : Number.MAX_SAFE_INTEGER;
  const min = element.min ? +element.min : Number.MIN_SAFE_INTEGER;
  if (value > max || value < min)
    return;
  element.value = value.toString();
  await _FU2U6RZLcjs.dispatch.input(element);
  await _FU2U6RZLcjs.dispatch.change(element);
}
var keyDownMap = {
  async Tab(_, { shiftKey }) {
    const nextElement = shiftKey ? _focus.getPreviousTabbable.call(void 0, ) : _focus.getNextTabbable.call(void 0, );
    if (nextElement) {
      await _A5IFXY4Jcjs.focus.call(void 0, nextElement);
    }
  },
  async Enter(element, options) {
    const nonSubmittableTypes = [...clickableInputTypes, "hidden"];
    const isClickable = element.tagName === "BUTTON" || element instanceof HTMLInputElement && clickableInputTypes.includes(element.type);
    const isSubmittable = element instanceof HTMLInputElement && !nonSubmittableTypes.includes(element.type);
    if (isClickable) {
      await _FU2U6RZLcjs.dispatch.click(element, options);
    } else if (isSubmittable) {
      await submitFormByPressingEnterOn(element, options);
    }
  },
  async ArrowLeft(element, { shiftKey }) {
    if (_dom.isTextField.call(void 0, element)) {
      const { value, selectionStart, selectionEnd, selectionDirection } = element;
      const [start, end] = [selectionStart != null ? selectionStart : 0, selectionEnd != null ? selectionEnd : 0];
      const collapsing = !shiftKey && start !== end;
      const nextStart = Math.max(0, collapsing ? start : start - 1);
      const nextEnd = Math.min(value.length, shiftKey ? end : nextStart);
      element.setSelectionRange(
        nextStart,
        nextEnd,
        selectionDirection || "backward"
      );
    }
  },
  async ArrowRight(element, { shiftKey }) {
    if (_dom.isTextField.call(void 0, element)) {
      const { value, selectionStart, selectionEnd, selectionDirection } = element;
      const [start, end] = [selectionStart != null ? selectionStart : 0, selectionEnd != null ? selectionEnd : 0];
      const collapsing = !shiftKey && start !== end;
      const nextEnd = Math.min(value.length, collapsing ? end : end + 1);
      const nextStart = Math.max(0, shiftKey ? start : nextEnd);
      element.setSelectionRange(
        nextStart,
        nextEnd,
        selectionDirection || "forward"
      );
    }
  },
  async ArrowUp(element, { shiftKey }) {
    if (_dom.isTextField.call(void 0, element)) {
      if (!shiftKey) {
        return element.setSelectionRange(0, 0);
      } else {
        const { selectionStart, selectionEnd, selectionDirection } = element;
        const [start, end] = [selectionStart != null ? selectionStart : 0, selectionEnd != null ? selectionEnd : 0];
        if (selectionDirection === "forward") {
          element.setSelectionRange(start, start);
        } else {
          element.setSelectionRange(0, end, "backward");
        }
      }
    } else if (isNumberInput(element)) {
      await incrementNumberInput(element);
    }
  },
  async ArrowDown(element, { shiftKey }) {
    if (_dom.isTextField.call(void 0, element)) {
      const length = element.value.length;
      if (!shiftKey) {
        element.setSelectionRange(length, length);
      } else {
        const { selectionStart, selectionEnd, selectionDirection } = element;
        const [start, end] = [selectionStart != null ? selectionStart : 0, selectionEnd != null ? selectionEnd : 0];
        if (selectionDirection === "backward") {
          element.setSelectionRange(end, end);
        } else {
          element.setSelectionRange(start, length, "forward");
        }
      }
    } else if (isNumberInput(element)) {
      await incrementNumberInput(element, -1);
    }
  }
};
var keyUpMap = {
  // Space
  " ": async (element, options) => {
    const spaceableTypes = [...clickableInputTypes, "checkbox", "radio"];
    const isSpaceable = element.tagName === "BUTTON" || element instanceof HTMLInputElement && spaceableTypes.includes(element.type);
    if (isSpaceable) {
      await _FU2U6RZLcjs.dispatch.click(element, options);
    }
  }
};
function press(key, element, options = {}) {
  return _ZMMVJ3OTcjs.wrapAsync.call(void 0, async () => {
    var _a, _b, _c, _d;
    if (element == null) {
      element = document.activeElement || document.body;
    }
    if (!element)
      return;
    if (!_focus.isFocusable.call(void 0, element) && element.tagName !== "BODY")
      return;
    if (_dom.isTextField.call(void 0, element)) {
      if (key.length === 1) {
        return _VZINRVVHcjs.type.call(void 0, key, element, options);
      } else if (key === "Delete") {
        return _VZINRVVHcjs.type.call(void 0, "\x7F", element, options);
      } else if (key === "Backspace") {
        return _VZINRVVHcjs.type.call(void 0, "\b", element, options);
      } else if (key === "Enter" && element.tagName === "TEXTAREA") {
        return _VZINRVVHcjs.type.call(void 0, "\n", element, options);
      }
    }
    if (((_a = element.ownerDocument) == null ? void 0 : _a.activeElement) !== element) {
      if (element.tagName === "BODY") {
        await _KVNENCXTcjs.blur.call(void 0, );
      } else {
        await _A5IFXY4Jcjs.focus.call(void 0, element);
      }
    }
    await _NIEATM7Rcjs.sleep.call(void 0, );
    let defaultAllowed = await _FU2U6RZLcjs.dispatch.keyDown(element, _OVN5OYWKcjs.__spreadValues.call(void 0, { key }, options));
    if (defaultAllowed && key in keyDownMap && !options.metaKey) {
      await ((_b = keyDownMap[key]) == null ? void 0 : _b.call(keyDownMap, element, options));
    }
    await _NIEATM7Rcjs.sleep.call(void 0, );
    if (((_c = element.ownerDocument) == null ? void 0 : _c.activeElement) !== element) {
      element = element.ownerDocument.activeElement;
    }
    if (!await _FU2U6RZLcjs.dispatch.keyUp(element, _OVN5OYWKcjs.__spreadValues.call(void 0, { key }, options))) {
      defaultAllowed = false;
    }
    if (defaultAllowed && key in keyUpMap && !options.metaKey) {
      await ((_d = keyUpMap[key]) == null ? void 0 : _d.call(keyUpMap, element, options));
    }
    await _NIEATM7Rcjs.sleep.call(void 0, );
  });
}
function createPress(key, defaultOptions = {}) {
  return (element, options = {}) => press(key, element, _OVN5OYWKcjs.__spreadValues.call(void 0, _OVN5OYWKcjs.__spreadValues.call(void 0, {}, defaultOptions), options));
}
press.Escape = createPress("Escape");
press.Backspace = createPress("Backspace");
press.Delete = createPress("Delete");
press.Tab = createPress("Tab");
press.ShiftTab = createPress("Tab", { shiftKey: true });
press.Enter = createPress("Enter");
press.Space = createPress(" ");
press.ArrowUp = createPress("ArrowUp");
press.ArrowRight = createPress("ArrowRight");
press.ArrowDown = createPress("ArrowDown");
press.ArrowLeft = createPress("ArrowLeft");
press.End = createPress("End");
press.Home = createPress("Home");
press.PageUp = createPress("PageUp");
press.PageDown = createPress("PageDown");



exports.press = press;
