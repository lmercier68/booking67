"use client";

// src/__utils.ts
import { isFocusable } from "@ariakit/core/utils/focus";
import { noop } from "@ariakit/core/utils/misc";
var isBrowser = typeof navigator !== "undefined" && !navigator.userAgent.includes("jsdom") && typeof window !== "undefined" && !("happyDOM" in window);
async function flushMicrotasks() {
  await Promise.resolve();
  await Promise.resolve();
  await Promise.resolve();
}
function nextFrame() {
  return new Promise(requestAnimationFrame);
}
function setActEnvironment(value) {
  const scope = globalThis;
  const previousValue = scope.IS_REACT_ACT_ENVIRONMENT;
  scope.IS_REACT_ACT_ENVIRONMENT = value;
  const restoreActEnvironment = () => {
    scope.IS_REACT_ACT_ENVIRONMENT = previousValue;
  };
  return restoreActEnvironment;
}
function applyBrowserPolyfills() {
  if (isBrowser)
    return noop;
  const originalFocus = HTMLElement.prototype.focus;
  HTMLElement.prototype.focus = function focus(options) {
    if (!isFocusable(this))
      return;
    return originalFocus.call(this, options);
  };
  const originalGetClientRects = Element.prototype.getClientRects;
  Element.prototype.getClientRects = function getClientRects() {
    const isHidden = (element) => {
      if (!element.isConnected)
        return true;
      if (element.parentElement && isHidden(element.parentElement))
        return true;
      if (!(element instanceof HTMLElement))
        return false;
      if (element.hidden)
        return true;
      const style = getComputedStyle(element);
      return style.display === "none" || style.visibility === "hidden";
    };
    if (isHidden(this))
      return [];
    return [{ width: 1, height: 1 }];
  };
  return () => {
    HTMLElement.prototype.focus = originalFocus;
    Element.prototype.getClientRects = originalGetClientRects;
  };
}
async function wrapAsync(fn) {
  const restoreActEnvironment = setActEnvironment(false);
  const removeBrowserPolyfills = applyBrowserPolyfills();
  try {
    return await fn();
  } finally {
    restoreActEnvironment();
    removeBrowserPolyfills();
  }
}

export {
  isBrowser,
  flushMicrotasks,
  nextFrame,
  wrapAsync
};
