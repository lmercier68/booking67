"use client";
import {
  focus
} from "./WAYMNUAF.js";
import {
  dispatch
} from "./7JP5HWUW.js";
import {
  sleep
} from "./YNAZUNNE.js";
import {
  wrapAsync
} from "./LHKK7Y5F.js";
import {
  __spreadValues
} from "./Q65FZOE2.js";

// src/type.ts
import { getActiveElement, isTextField } from "@ariakit/core/utils/dom";
import { isFocusable } from "@ariakit/core/utils/focus";
function getKeyFromChar(key) {
  if (key === "\x7F")
    return "Delete";
  if (key === "\b")
    return "Backspace";
  if (key === "\n")
    return "Enter";
  if (key === "	")
    return "Tab";
  return key;
}
function workAroundEmailInput(element) {
  const input = element;
  if (input.tagName !== "INPUT" || input.type !== "email")
    return () => {
    };
  input.type = "text";
  return () => {
    input.type = "email";
  };
}
function type(text, element, options = {}) {
  return wrapAsync(async () => {
    var _a, _b;
    if (element == null) {
      element = document.activeElement;
    }
    if (!element)
      return;
    if (!isFocusable(element))
      return;
    await focus(element);
    element.dirty = true;
    const restoreEmailInput = workAroundEmailInput(element);
    for (const char of text) {
      const key = getKeyFromChar(char);
      let value = "";
      let inputType = options.isComposing ? "insertCompositionText" : "insertText";
      let defaultAllowed = await dispatch.keyDown(element, __spreadValues({ key }, options));
      element = getActiveElement(element) || element;
      if (isTextField(element)) {
        const input = element;
        const [start, end] = [
          (_a = input.selectionStart) != null ? _a : 0,
          (_b = input.selectionEnd) != null ? _b : 0
        ];
        const collapsed = start === end;
        let nextCaretPosition = start;
        if (char === "\x7F") {
          const firstPart = input.value.slice(0, start);
          const secondPart = input.value.slice(collapsed ? end + 1 : end);
          value = `${firstPart}${secondPart}`;
          inputType = "deleteContentForward";
        } else if (char === "\b") {
          nextCaretPosition = collapsed ? Math.max(start - 1, 0) : start;
          const firstPart = input.value.slice(0, nextCaretPosition);
          const lastPart = input.value.slice(end, input.value.length);
          value = `${firstPart}${lastPart}`;
          inputType = "deleteContentBackward";
        } else {
          const firstPartEnd = options.isComposing ? start - 1 : start;
          const firstPart = input.value.slice(0, firstPartEnd);
          const lastPart = input.value.slice(end, input.value.length);
          nextCaretPosition = start + 1;
          value = `${firstPart}${char}${lastPart}`;
        }
        if (defaultAllowed && !input.readOnly) {
          if (inputType === "insertText") {
            defaultAllowed = await dispatch.keyPress(input, __spreadValues({
              key,
              charCode: key.charCodeAt(0)
            }, options));
          }
          if (inputType === "insertCompositionText") {
            defaultAllowed = await dispatch.compositionUpdate(input, __spreadValues({
              data: char,
              target: { value }
            }, options));
          }
          if (defaultAllowed) {
            await dispatch.input(input, __spreadValues({
              data: char,
              target: {
                value,
                selectionStart: nextCaretPosition,
                selectionEnd: nextCaretPosition
              },
              inputType
            }, options));
            if (input.selectionStart !== nextCaretPosition) {
              input.setSelectionRange(nextCaretPosition, nextCaretPosition);
            }
          }
        }
      }
      await sleep();
      await dispatch.keyUp(element, __spreadValues({ key }, options));
      await sleep();
    }
    restoreEmailInput();
  });
}

export {
  type
};
