"use client";
import {
  type
} from "./HVRX3U4O.js";
import {
  blur
} from "./ZIWQZF7I.js";
import {
  focus
} from "./WAYMNUAF.js";
import {
  dispatch
} from "./7JP5HWUW.js";
import {
  sleep
} from "./YNAZUNNE.js";
import {
  wrapAsync
} from "./LHKK7Y5F.js";
import {
  __spreadValues
} from "./Q65FZOE2.js";

// src/press.ts
import { isTextField } from "@ariakit/core/utils/dom";
import {
  getNextTabbable,
  getPreviousTabbable,
  isFocusable
} from "@ariakit/core/utils/focus";
var clickableInputTypes = [
  "button",
  "color",
  "file",
  "image",
  "reset",
  "submit"
];
async function submitFormByPressingEnterOn(element, options) {
  const { form } = element;
  if (!form)
    return;
  const elements = Array.from(form.elements);
  const validInputs = elements.filter(
    (el) => el instanceof HTMLInputElement && isTextField(el)
  );
  const submitButton = elements.find(
    (el) => (el instanceof HTMLInputElement || el instanceof HTMLButtonElement) && el.type === "submit"
  );
  if (validInputs.length === 1 || submitButton) {
    await dispatch.submit(form, options);
  }
}
function isNumberInput(element) {
  return element instanceof HTMLInputElement && element.type === "number";
}
async function incrementNumberInput(element, by = 1) {
  const value = +element.value + by;
  const max = element.max ? +element.max : Number.MAX_SAFE_INTEGER;
  const min = element.min ? +element.min : Number.MIN_SAFE_INTEGER;
  if (value > max || value < min)
    return;
  element.value = value.toString();
  await dispatch.input(element);
  await dispatch.change(element);
}
var keyDownMap = {
  async Tab(_, { shiftKey }) {
    const nextElement = shiftKey ? getPreviousTabbable() : getNextTabbable();
    if (nextElement) {
      await focus(nextElement);
    }
  },
  async Enter(element, options) {
    const nonSubmittableTypes = [...clickableInputTypes, "hidden"];
    const isClickable = element.tagName === "BUTTON" || element instanceof HTMLInputElement && clickableInputTypes.includes(element.type);
    const isSubmittable = element instanceof HTMLInputElement && !nonSubmittableTypes.includes(element.type);
    if (isClickable) {
      await dispatch.click(element, options);
    } else if (isSubmittable) {
      await submitFormByPressingEnterOn(element, options);
    }
  },
  async ArrowLeft(element, { shiftKey }) {
    if (isTextField(element)) {
      const { value, selectionStart, selectionEnd, selectionDirection } = element;
      const [start, end] = [selectionStart != null ? selectionStart : 0, selectionEnd != null ? selectionEnd : 0];
      const collapsing = !shiftKey && start !== end;
      const nextStart = Math.max(0, collapsing ? start : start - 1);
      const nextEnd = Math.min(value.length, shiftKey ? end : nextStart);
      element.setSelectionRange(
        nextStart,
        nextEnd,
        selectionDirection || "backward"
      );
    }
  },
  async ArrowRight(element, { shiftKey }) {
    if (isTextField(element)) {
      const { value, selectionStart, selectionEnd, selectionDirection } = element;
      const [start, end] = [selectionStart != null ? selectionStart : 0, selectionEnd != null ? selectionEnd : 0];
      const collapsing = !shiftKey && start !== end;
      const nextEnd = Math.min(value.length, collapsing ? end : end + 1);
      const nextStart = Math.max(0, shiftKey ? start : nextEnd);
      element.setSelectionRange(
        nextStart,
        nextEnd,
        selectionDirection || "forward"
      );
    }
  },
  async ArrowUp(element, { shiftKey }) {
    if (isTextField(element)) {
      if (!shiftKey) {
        return element.setSelectionRange(0, 0);
      } else {
        const { selectionStart, selectionEnd, selectionDirection } = element;
        const [start, end] = [selectionStart != null ? selectionStart : 0, selectionEnd != null ? selectionEnd : 0];
        if (selectionDirection === "forward") {
          element.setSelectionRange(start, start);
        } else {
          element.setSelectionRange(0, end, "backward");
        }
      }
    } else if (isNumberInput(element)) {
      await incrementNumberInput(element);
    }
  },
  async ArrowDown(element, { shiftKey }) {
    if (isTextField(element)) {
      const length = element.value.length;
      if (!shiftKey) {
        element.setSelectionRange(length, length);
      } else {
        const { selectionStart, selectionEnd, selectionDirection } = element;
        const [start, end] = [selectionStart != null ? selectionStart : 0, selectionEnd != null ? selectionEnd : 0];
        if (selectionDirection === "backward") {
          element.setSelectionRange(end, end);
        } else {
          element.setSelectionRange(start, length, "forward");
        }
      }
    } else if (isNumberInput(element)) {
      await incrementNumberInput(element, -1);
    }
  }
};
var keyUpMap = {
  // Space
  " ": async (element, options) => {
    const spaceableTypes = [...clickableInputTypes, "checkbox", "radio"];
    const isSpaceable = element.tagName === "BUTTON" || element instanceof HTMLInputElement && spaceableTypes.includes(element.type);
    if (isSpaceable) {
      await dispatch.click(element, options);
    }
  }
};
function press(key, element, options = {}) {
  return wrapAsync(async () => {
    var _a, _b, _c, _d;
    if (element == null) {
      element = document.activeElement || document.body;
    }
    if (!element)
      return;
    if (!isFocusable(element) && element.tagName !== "BODY")
      return;
    if (isTextField(element)) {
      if (key.length === 1) {
        return type(key, element, options);
      } else if (key === "Delete") {
        return type("\x7F", element, options);
      } else if (key === "Backspace") {
        return type("\b", element, options);
      } else if (key === "Enter" && element.tagName === "TEXTAREA") {
        return type("\n", element, options);
      }
    }
    if (((_a = element.ownerDocument) == null ? void 0 : _a.activeElement) !== element) {
      if (element.tagName === "BODY") {
        await blur();
      } else {
        await focus(element);
      }
    }
    await sleep();
    let defaultAllowed = await dispatch.keyDown(element, __spreadValues({ key }, options));
    if (defaultAllowed && key in keyDownMap && !options.metaKey) {
      await ((_b = keyDownMap[key]) == null ? void 0 : _b.call(keyDownMap, element, options));
    }
    await sleep();
    if (((_c = element.ownerDocument) == null ? void 0 : _c.activeElement) !== element) {
      element = element.ownerDocument.activeElement;
    }
    if (!await dispatch.keyUp(element, __spreadValues({ key }, options))) {
      defaultAllowed = false;
    }
    if (defaultAllowed && key in keyUpMap && !options.metaKey) {
      await ((_d = keyUpMap[key]) == null ? void 0 : _d.call(keyUpMap, element, options));
    }
    await sleep();
  });
}
function createPress(key, defaultOptions = {}) {
  return (element, options = {}) => press(key, element, __spreadValues(__spreadValues({}, defaultOptions), options));
}
press.Escape = createPress("Escape");
press.Backspace = createPress("Backspace");
press.Delete = createPress("Delete");
press.Tab = createPress("Tab");
press.ShiftTab = createPress("Tab", { shiftKey: true });
press.Enter = createPress("Enter");
press.Space = createPress(" ");
press.ArrowUp = createPress("ArrowUp");
press.ArrowRight = createPress("ArrowRight");
press.ArrowDown = createPress("ArrowDown");
press.ArrowLeft = createPress("ArrowLeft");
press.End = createPress("End");
press.Home = createPress("Home");
press.PageUp = createPress("PageUp");
press.PageDown = createPress("PageDown");

export {
  press
};
