"use client";
import {
  mouseUp
} from "./LSH2PT34.js";
import {
  mouseDown
} from "./RG2JKALK.js";
import {
  hover
} from "./ANPGABTJ.js";
import {
  dispatch
} from "./7JP5HWUW.js";
import {
  sleep
} from "./YNAZUNNE.js";
import {
  wrapAsync
} from "./LHKK7Y5F.js";
import {
  __spreadValues
} from "./Q65FZOE2.js";

// src/select.ts
import { isVisible } from "@ariakit/core/utils/dom";
import { invariant } from "@ariakit/core/utils/misc";
function select(text, element = document.body, options) {
  return wrapAsync(async () => {
    var _a, _b;
    invariant(element, "Unable to select text on null element");
    if (!isVisible(element))
      return;
    const document2 = element.ownerDocument;
    await hover(element, options);
    await mouseDown(element, options);
    await dispatch(
      element,
      new Event("selectstart", {
        bubbles: true,
        cancelable: true,
        composed: false
      })
    );
    const startIndex = (_b = (_a = element.textContent) == null ? void 0 : _a.indexOf(text)) != null ? _b : -1;
    const selection = document2.getSelection();
    const range = document2.createRange();
    for (let i = 1; i <= text.length; i++) {
      const iterator = document2.createNodeIterator(
        element,
        NodeFilter.SHOW_TEXT
      );
      const textSlice = text.slice(0, i);
      const endIndex = startIndex + textSlice.length;
      let index = startIndex;
      let node = null;
      let charCount = 0;
      let startContainer = null;
      let startOffset = -1;
      let endContainer = null;
      let endOffset = -1;
      while (index >= 0 && index < endIndex && charCount < endIndex && (node = iterator.nextNode())) {
        const textContent = node.textContent;
        if (!textContent)
          continue;
        charCount += textContent.length;
        if (index > charCount)
          continue;
        if (!startContainer) {
          startContainer = node;
          startOffset = index - charCount + textContent.length;
        }
        endContainer = node;
        endOffset = endIndex - charCount + textContent.length;
        index++;
      }
      if (!startContainer || !endContainer)
        continue;
      await hover(element, options);
      range.setStart(startContainer, startOffset);
      range.setEnd(endContainer, endOffset);
      selection == null ? void 0 : selection.removeAllRanges();
      selection == null ? void 0 : selection.addRange(range);
    }
    await sleep();
    await mouseUp(element, options);
    await dispatch.click(element, __spreadValues({ detail: 1 }, options));
    selection == null ? void 0 : selection.removeAllRanges();
    selection == null ? void 0 : selection.addRange(range);
    await sleep();
  });
}

export {
  select
};
